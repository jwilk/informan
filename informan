#!/usr/bin/env perl

# Copyright Â© 2022 Jakub Wilk <jwilk@jwilk.net>
# SPDX-License-Identifier: MIT

no lib '.';  # CVE-2016-1238
use strict;
use warnings;


use Encode::Alias ();
use English qw(-no_match_vars);
use File::Temp ();
use I18N::Langinfo (qw(langinfo CODESET));

use File::Which ();
use IPC::System::Simple ();

{
    my $encoding = langinfo(CODESET) // 'ASCII';
    Encode::Alias::define_alias('locale' => $encoding);
}

sub embolden
{
    local ($_) = @_;
    s/(\X)/$1\b$1/g;
    return $_;
}

my $tmpdir = File::Temp->newdir(TEMPLATE => 'informan.XXXXXX', TMPDIR => 1);
my $bin_false = File::Which::which('false')
    or die 'false(1) not found';
symlink($bin_false, "$tmpdir/man")
    or die "symlink(): $ERRNO";
my $PATH = $ENV{PATH} // '';
length $PATH > 0
    or die "empty $PATH is not supported";
$PATH = "$tmpdir:$PATH";
my @text = do {
    local $ENV{PATH} = $PATH;
    local $INPUT_RECORD_SEPARATOR = '';
    IPC::System::Simple::capturex('info', @ARGV);
};
scalar @text > 0
    # This happens when info(1) can't find the page.
    # Huh? https://bugs.debian.org/1021827
    or die 'info(1) failed';
my $ul_chars = '*=-.';
my $ul_re = join('|', map { "[$_]+" } split(//, $ul_chars));
for my $text (@text) {
    $text = Encode::decode('locale', $text);
    $text =~ s{^(\S.+)(?=\n(?:$ul_re)\n)}{embolden($1)}ge;
    $text = Encode::encode('locale', $text);
}
my $pager = $ENV{PAGER}
    // File::Which::which('pager')  # Debian <https://www.debian.org/doc/debian-policy/ch-customized-programs.html#editors-and-pagers>
    // 'more';  # POSIX <https://pubs.opengroup.org/onlinepubs/007904975/utilities/man.html#tag_04_85_08>
if ($pager eq 'cat') {
    $pager = undef;
}
if (not -t *STDOUT) {
    $pager = undef;
}
if (@ARGV >= 1 and $ARGV[0] =~ m/\A(-h|--help|--version)\Z/) {
    $pager = undef;
}
if (defined $pager) {
    open(my $fh, '|-', 'sh', '-c', $pager)
        or die "pager: $ERRNO";
    for my $text (@text) {
        print {$fh} $text
            or die "pager: $ERRNO";
    }
    close($fh)
        or die 'pager: ' . ($ERRNO or 'failed');
} else {
    for my $text (@text) {
        print $text
            or die $ERRNO;
    }
}

# vim:ts=4 sts=4 sw=4 et
